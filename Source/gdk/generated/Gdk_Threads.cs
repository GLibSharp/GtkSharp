// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gdk {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Threads {

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gdk_threads_add_idle_full(int priority, GLibSharp.GSourceFuncNative function, IntPtr data, GLib.DestroyNotify notify);

		public static uint AddIdle(int priority, GLib.GSourceFunc function) {
			GLibSharp.GSourceFuncWrapper function_wrapper = new GLibSharp.GSourceFuncWrapper (function);
			IntPtr data;
			GLib.DestroyNotify notify;
			if (function == null) {
				data = IntPtr.Zero;
				notify = null;
			} else {
				data = (IntPtr) GCHandle.Alloc (function_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			uint raw_ret = gdk_threads_add_idle_full(priority, function_wrapper.NativeDelegate, data, notify);
			uint ret = raw_ret;
			return ret;
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gdk_threads_add_timeout_full(int priority, uint interval, GLibSharp.GSourceFuncNative function, IntPtr data, GLib.DestroyNotify notify);

		public static uint AddTimeout(int priority, uint interval, GLib.GSourceFunc function) {
			GLibSharp.GSourceFuncWrapper function_wrapper = new GLibSharp.GSourceFuncWrapper (function);
			IntPtr data;
			GLib.DestroyNotify notify;
			if (function == null) {
				data = IntPtr.Zero;
				notify = null;
			} else {
				data = (IntPtr) GCHandle.Alloc (function_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			uint raw_ret = gdk_threads_add_timeout_full(priority, interval, function_wrapper.NativeDelegate, data, notify);
			uint ret = raw_ret;
			return ret;
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gdk_threads_add_timeout_seconds_full(int priority, uint interval, GLibSharp.GSourceFuncNative function, IntPtr data, GLib.DestroyNotify notify);

		public static uint AddTimeoutSeconds(int priority, uint interval, GLib.GSourceFunc function) {
			GLibSharp.GSourceFuncWrapper function_wrapper = new GLibSharp.GSourceFuncWrapper (function);
			IntPtr data;
			GLib.DestroyNotify notify;
			if (function == null) {
				data = IntPtr.Zero;
				notify = null;
			} else {
				data = (IntPtr) GCHandle.Alloc (function_wrapper);
				notify = GLib.DestroyHelper.NotifyHandler;
			}
			uint raw_ret = gdk_threads_add_timeout_seconds_full(priority, interval, function_wrapper.NativeDelegate, data, notify);
			uint ret = raw_ret;
			return ret;
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gdk_threads_enter();

		[Obsolete]
		public static void Enter() {
			gdk_threads_enter();
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gdk_threads_init();

		[Obsolete]
		public static void Init() {
			gdk_threads_init();
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gdk_threads_leave();

		[Obsolete]
		public static void Leave() {
			gdk_threads_leave();
		}

#endregion
	}
}
