// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class CellLayoutAdapter : GLib.GInterfaceAdapter, Gtk.ICellLayout {

		[StructLayout (LayoutKind.Sequential)]
		struct GtkCellLayoutIface {
			public PackStartNativeDelegate PackStart;
			public PackEndNativeDelegate PackEnd;
			public ClearNativeDelegate Clear;
			public AddAttributeNativeDelegate AddAttribute;
			public SetCellDataFuncNativeDelegate SetCellDataFunc;
			public ClearAttributesNativeDelegate ClearAttributes;
			public ReorderNativeDelegate Reorder;
			public GetCellsNativeDelegate GetCells;
			public GetAreaNativeDelegate GetArea;
		}

		static GtkCellLayoutIface iface;

		static CellLayoutAdapter ()
		{
			GLib.GType.Register (_gtype, typeof (CellLayoutAdapter));
			iface.PackStart = new PackStartNativeDelegate (PackStart_cb);
			iface.PackEnd = new PackEndNativeDelegate (PackEnd_cb);
			iface.Clear = new ClearNativeDelegate (Clear_cb);
			iface.AddAttribute = new AddAttributeNativeDelegate (AddAttribute_cb);
			iface.SetCellDataFunc = new SetCellDataFuncNativeDelegate (SetCellDataFunc_cb);
			iface.ClearAttributes = new ClearAttributesNativeDelegate (ClearAttributes_cb);
			iface.Reorder = new ReorderNativeDelegate (Reorder_cb);
			iface.GetCells = new GetCellsNativeDelegate (GetCells_cb);
			iface.GetArea = new GetAreaNativeDelegate (GetArea_cb);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PackStartNativeDelegate (IntPtr inst, IntPtr cell, bool expand);

		static void PackStart_cb (IntPtr inst, IntPtr cell, bool expand)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				__obj.PackStart (GLib.Object.GetObject(cell) as Gtk.CellRenderer, expand);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void PackEndNativeDelegate (IntPtr inst, IntPtr cell, bool expand);

		static void PackEnd_cb (IntPtr inst, IntPtr cell, bool expand)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				__obj.PackEnd (GLib.Object.GetObject(cell) as Gtk.CellRenderer, expand);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ClearNativeDelegate (IntPtr inst);

		static void Clear_cb (IntPtr inst)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				__obj.Clear ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AddAttributeNativeDelegate (IntPtr inst, IntPtr cell, IntPtr attribute, int column);

		static void AddAttribute_cb (IntPtr inst, IntPtr cell, IntPtr attribute, int column)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				__obj.AddAttribute (GLib.Object.GetObject(cell) as Gtk.CellRenderer, GLib.Marshaller.Utf8PtrToString (attribute), column);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void SetCellDataFuncNativeDelegate (IntPtr inst, IntPtr cell, GtkSharp.CellLayoutDataFuncNative func, IntPtr func_data, GLib.DestroyNotify destroy);

		static void SetCellDataFunc_cb (IntPtr inst, IntPtr cell, GtkSharp.CellLayoutDataFuncNative func, IntPtr func_data, GLib.DestroyNotify destroy)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				GtkSharp.CellLayoutDataFuncInvoker func_invoker = new GtkSharp.CellLayoutDataFuncInvoker (func, func_data, destroy);
				__obj.SetCellDataFunc (GLib.Object.GetObject(cell) as Gtk.CellRenderer, func_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ClearAttributesNativeDelegate (IntPtr inst, IntPtr cell);

		static void ClearAttributes_cb (IntPtr inst, IntPtr cell)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				__obj.ClearAttributes (GLib.Object.GetObject(cell) as Gtk.CellRenderer);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ReorderNativeDelegate (IntPtr inst, IntPtr cell, int position);

		static void Reorder_cb (IntPtr inst, IntPtr cell, int position)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				__obj.Reorder (GLib.Object.GetObject(cell) as Gtk.CellRenderer, position);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetCellsNativeDelegate (IntPtr inst);

		static IntPtr GetCells_cb (IntPtr inst)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				Gtk.CellRenderer[] __result;
				__result = __obj.Cells;
				return new GLib.List(__result, typeof (Gtk.CellRenderer), true, false) == null ? IntPtr.Zero : new GLib.List(__result, typeof (Gtk.CellRenderer), true, false).Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetAreaNativeDelegate (IntPtr inst);

		static IntPtr GetArea_cb (IntPtr inst)
		{
			try {
				ICellLayoutImplementor __obj = GLib.Object.GetObject (inst, false) as ICellLayoutImplementor;
				Gtk.CellArea __result;
				__result = __obj.Area;
				return __result == null ? IntPtr.Zero : __result.Handle;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		static int class_offset = 2 * IntPtr.Size;

		static void Initialize (IntPtr ptr, IntPtr data)
		{
			IntPtr ifaceptr = new IntPtr (ptr.ToInt64 () + class_offset);
			GtkCellLayoutIface native_iface = (GtkCellLayoutIface) Marshal.PtrToStructure (ifaceptr, typeof (GtkCellLayoutIface));
			native_iface.PackStart = iface.PackStart;
			native_iface.PackEnd = iface.PackEnd;
			native_iface.Clear = iface.Clear;
			native_iface.AddAttribute = iface.AddAttribute;
			native_iface.SetCellDataFunc = iface.SetCellDataFunc;
			native_iface.ClearAttributes = iface.ClearAttributes;
			native_iface.Reorder = iface.Reorder;
			native_iface.GetCells = iface.GetCells;
			native_iface.GetArea = iface.GetArea;
			Marshal.StructureToPtr (native_iface, ifaceptr, false);
		}

		GLib.Object implementor;

		public CellLayoutAdapter ()
		{
			InitHandler = new GLib.GInterfaceInitHandler (Initialize);
		}

		public CellLayoutAdapter (ICellLayoutImplementor implementor)
		{
			if (implementor == null)
				throw new ArgumentNullException ("implementor");
			else if (!(implementor is GLib.Object))
				throw new ArgumentException ("implementor must be a subclass of GLib.Object");
			this.implementor = implementor as GLib.Object;
		}

		public CellLayoutAdapter (IntPtr handle)
		{
			if (!_gtype.IsInstance (handle))
				throw new ArgumentException ("The gobject doesn't implement the GInterface of this adapter", "handle");
			implementor = GLib.Object.GetObject (handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_cell_layout_get_type();

		private static GLib.GType _gtype = new GLib.GType (gtk_cell_layout_get_type ());

		public static GLib.GType GType {
			get {
				return _gtype;
			}
		}

		public override GLib.GType GInterfaceGType {
			get {
				return _gtype;
			}
		}

		public override IntPtr Handle {
			get {
				return implementor.Handle;
			}
		}

		public IntPtr OwnedHandle {
			get {
				return implementor.OwnedHandle;
			}
		}

		public static ICellLayout GetObject (IntPtr handle, bool owned)
		{
			GLib.Object obj = GLib.Object.GetObject (handle, owned);
			return GetObject (obj);
		}

		public static ICellLayout GetObject (GLib.Object obj)
		{
			if (obj == null)
				return null;
			else if (obj is ICellLayoutImplementor)
				return new CellLayoutAdapter (obj as ICellLayoutImplementor);
			else if (obj as ICellLayout == null)
				return new CellLayoutAdapter (obj.Handle);
			else
				return obj as ICellLayout;
		}

		public ICellLayoutImplementor Implementor {
			get {
				return implementor as ICellLayoutImplementor;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_add_attribute(IntPtr raw, IntPtr cell, IntPtr attribute, int column);

		public void AddAttribute(Gtk.CellRenderer cell, string attribute, int column) {
			IntPtr native_attribute = GLib.Marshaller.StringToPtrGStrdup (attribute);
			gtk_cell_layout_add_attribute(Handle, cell == null ? IntPtr.Zero : cell.Handle, native_attribute, column);
			GLib.Marshaller.Free (native_attribute);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_clear(IntPtr raw);

		public void Clear() {
			gtk_cell_layout_clear(Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_clear_attributes(IntPtr raw, IntPtr cell);

		public void ClearAttributes(Gtk.CellRenderer cell) {
			gtk_cell_layout_clear_attributes(Handle, cell == null ? IntPtr.Zero : cell.Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_cell_layout_get_area(IntPtr raw);

		public Gtk.CellArea Area { 
			get {
				IntPtr raw_ret = gtk_cell_layout_get_area(Handle);
				Gtk.CellArea ret = GLib.Object.GetObject(raw_ret) as Gtk.CellArea;
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_cell_layout_get_cells(IntPtr raw);

		public Gtk.CellRenderer[] Cells { 
			get {
				IntPtr raw_ret = gtk_cell_layout_get_cells(Handle);
				Gtk.CellRenderer[] ret = (Gtk.CellRenderer[]) GLib.Marshaller.ListPtrToArray (raw_ret, typeof(GLib.List), true, false, typeof(Gtk.CellRenderer));
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_pack_end(IntPtr raw, IntPtr cell, bool expand);

		public void PackEnd(Gtk.CellRenderer cell, bool expand) {
			gtk_cell_layout_pack_end(Handle, cell == null ? IntPtr.Zero : cell.Handle, expand);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_pack_start(IntPtr raw, IntPtr cell, bool expand);

		public void PackStart(Gtk.CellRenderer cell, bool expand) {
			gtk_cell_layout_pack_start(Handle, cell == null ? IntPtr.Zero : cell.Handle, expand);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_reorder(IntPtr raw, IntPtr cell, int position);

		public void Reorder(Gtk.CellRenderer cell, int position) {
			gtk_cell_layout_reorder(Handle, cell == null ? IntPtr.Zero : cell.Handle, position);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_cell_layout_set_cell_data_func(IntPtr raw, IntPtr cell, GtkSharp.CellLayoutDataFuncNative func, IntPtr func_data, GLib.DestroyNotify destroy);

		public void SetCellDataFunc(Gtk.CellRenderer cell, Gtk.CellLayoutDataFunc func) {
			GtkSharp.CellLayoutDataFuncWrapper func_wrapper = new GtkSharp.CellLayoutDataFuncWrapper (func);
			IntPtr func_data;
			GLib.DestroyNotify destroy;
			if (func == null) {
				func_data = IntPtr.Zero;
				destroy = null;
			} else {
				func_data = (IntPtr) GCHandle.Alloc (func_wrapper);
				destroy = GLib.DestroyHelper.NotifyHandler;
			}
			gtk_cell_layout_set_cell_data_func(Handle, cell == null ? IntPtr.Zero : cell.Handle, func_wrapper.NativeDelegate, func_data, destroy);
		}

#endregion
	}
}
