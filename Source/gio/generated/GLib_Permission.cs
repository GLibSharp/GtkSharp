// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace GLib {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Permission : GLib.Object {

		public Permission (IntPtr raw) : base(raw) {}

		protected Permission() : base(IntPtr.Zero)
		{
			CreateNativeObject (new string [0], new GLib.Value [0]);
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool g_permission_get_allowed(IntPtr raw);

		[GLib.Property ("allowed")]
		public bool Allowed {
			get  {
				bool raw_ret = g_permission_get_allowed(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool g_permission_get_can_acquire(IntPtr raw);

		[GLib.Property ("can-acquire")]
		public bool CanAcquire {
			get  {
				bool raw_ret = g_permission_get_can_acquire(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool g_permission_get_can_release(IntPtr raw);

		[GLib.Property ("can-release")]
		public bool CanRelease {
			get  {
				bool raw_ret = g_permission_get_can_release(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		static AcquireNativeDelegate Acquire_cb_delegate;
		static AcquireNativeDelegate AcquireVMCallback {
			get {
				if (Acquire_cb_delegate == null)
					Acquire_cb_delegate = new AcquireNativeDelegate (Acquire_cb);
				return Acquire_cb_delegate;
			}
		}

		static void OverrideAcquire (GLib.GType gtype)
		{
			OverrideAcquire (gtype, AcquireVMCallback);
		}

		static void OverrideAcquire (GLib.GType gtype, AcquireNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("acquire"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool AcquireNativeDelegate (IntPtr inst, IntPtr cancellable, out IntPtr error);

		static bool Acquire_cb (IntPtr inst, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				Permission __obj = GLib.Object.GetObject (inst, false) as Permission;
				bool __result;
				__result = __obj.OnAcquire (GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Permission), ConnectionMethod="OverrideAcquire")]
		protected virtual bool OnAcquire (GLib.Cancellable cancellable)
		{
			return InternalAcquire (cancellable);
		}

		private bool InternalAcquire (GLib.Cancellable cancellable)
		{
			AcquireNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("acquire"));
				unmanaged = (AcquireNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(AcquireNativeDelegate));
			}
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr error = IntPtr.Zero;
			bool __result = unmanaged (this.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			return __result;
		}

		static AcquireAsyncNativeDelegate AcquireAsync_cb_delegate;
		static AcquireAsyncNativeDelegate AcquireAsyncVMCallback {
			get {
				if (AcquireAsync_cb_delegate == null)
					AcquireAsync_cb_delegate = new AcquireAsyncNativeDelegate (AcquireAsync_cb);
				return AcquireAsync_cb_delegate;
			}
		}

		static void OverrideAcquireAsync (GLib.GType gtype)
		{
			OverrideAcquireAsync (gtype, AcquireAsyncVMCallback);
		}

		static void OverrideAcquireAsync (GLib.GType gtype, AcquireAsyncNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("acquire_async"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AcquireAsyncNativeDelegate (IntPtr inst, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void AcquireAsync_cb (IntPtr inst, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				Permission __obj = GLib.Object.GetObject (inst, false) as Permission;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.OnAcquireAsync (GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Permission), ConnectionMethod="OverrideAcquireAsync")]
		protected virtual void OnAcquireAsync (GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb)
		{
			InternalAcquireAsync (cancellable, cb);
		}

		private void InternalAcquireAsync (GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb)
		{
			AcquireAsyncNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("acquire_async"));
				unmanaged = (AcquireAsyncNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(AcquireAsyncNativeDelegate));
			}
			if (unmanaged == null) return;

			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			unmanaged (this.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		static AcquireFinishNativeDelegate AcquireFinish_cb_delegate;
		static AcquireFinishNativeDelegate AcquireFinishVMCallback {
			get {
				if (AcquireFinish_cb_delegate == null)
					AcquireFinish_cb_delegate = new AcquireFinishNativeDelegate (AcquireFinish_cb);
				return AcquireFinish_cb_delegate;
			}
		}

		static void OverrideAcquireFinish (GLib.GType gtype)
		{
			OverrideAcquireFinish (gtype, AcquireFinishVMCallback);
		}

		static void OverrideAcquireFinish (GLib.GType gtype, AcquireFinishNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("acquire_finish"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool AcquireFinishNativeDelegate (IntPtr inst, IntPtr result, out IntPtr error);

		static bool AcquireFinish_cb (IntPtr inst, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				Permission __obj = GLib.Object.GetObject (inst, false) as Permission;
				bool __result;
				__result = __obj.OnAcquireFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Permission), ConnectionMethod="OverrideAcquireFinish")]
		protected virtual bool OnAcquireFinish (GLib.IAsyncResult result)
		{
			return InternalAcquireFinish (result);
		}

		private bool InternalAcquireFinish (GLib.IAsyncResult result)
		{
			AcquireFinishNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("acquire_finish"));
				unmanaged = (AcquireFinishNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(AcquireFinishNativeDelegate));
			}
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr error = IntPtr.Zero;
			bool __result = unmanaged (this.Handle, result == null ? IntPtr.Zero : ((result is GLib.Object) ? (result as GLib.Object).Handle : (result as GLib.AsyncResultAdapter).Handle), out error);
			return __result;
		}

		static ReleaseNativeDelegate Release_cb_delegate;
		static ReleaseNativeDelegate ReleaseVMCallback {
			get {
				if (Release_cb_delegate == null)
					Release_cb_delegate = new ReleaseNativeDelegate (Release_cb);
				return Release_cb_delegate;
			}
		}

		static void OverrideRelease (GLib.GType gtype)
		{
			OverrideRelease (gtype, ReleaseVMCallback);
		}

		static void OverrideRelease (GLib.GType gtype, ReleaseNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("release"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ReleaseNativeDelegate (IntPtr inst, IntPtr cancellable, out IntPtr error);

		static bool Release_cb (IntPtr inst, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				Permission __obj = GLib.Object.GetObject (inst, false) as Permission;
				bool __result;
				__result = __obj.OnRelease (GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Permission), ConnectionMethod="OverrideRelease")]
		protected virtual bool OnRelease (GLib.Cancellable cancellable)
		{
			return InternalRelease (cancellable);
		}

		private bool InternalRelease (GLib.Cancellable cancellable)
		{
			ReleaseNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("release"));
				unmanaged = (ReleaseNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(ReleaseNativeDelegate));
			}
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr error = IntPtr.Zero;
			bool __result = unmanaged (this.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			return __result;
		}

		static ReleaseAsyncNativeDelegate ReleaseAsync_cb_delegate;
		static ReleaseAsyncNativeDelegate ReleaseAsyncVMCallback {
			get {
				if (ReleaseAsync_cb_delegate == null)
					ReleaseAsync_cb_delegate = new ReleaseAsyncNativeDelegate (ReleaseAsync_cb);
				return ReleaseAsync_cb_delegate;
			}
		}

		static void OverrideReleaseAsync (GLib.GType gtype)
		{
			OverrideReleaseAsync (gtype, ReleaseAsyncVMCallback);
		}

		static void OverrideReleaseAsync (GLib.GType gtype, ReleaseAsyncNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("release_async"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void ReleaseAsyncNativeDelegate (IntPtr inst, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		static void ReleaseAsync_cb (IntPtr inst, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data)
		{
			try {
				Permission __obj = GLib.Object.GetObject (inst, false) as Permission;
				GLibSharp.AsyncReadyCallbackInvoker cb_invoker = new GLibSharp.AsyncReadyCallbackInvoker (cb, user_data);
				__obj.OnReleaseAsync (GLib.Object.GetObject(cancellable) as GLib.Cancellable, cb_invoker.Handler);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Permission), ConnectionMethod="OverrideReleaseAsync")]
		protected virtual void OnReleaseAsync (GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb)
		{
			InternalReleaseAsync (cancellable, cb);
		}

		private void InternalReleaseAsync (GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb)
		{
			ReleaseAsyncNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("release_async"));
				unmanaged = (ReleaseAsyncNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(ReleaseAsyncNativeDelegate));
			}
			if (unmanaged == null) return;

			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			unmanaged (this.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		static ReleaseFinishNativeDelegate ReleaseFinish_cb_delegate;
		static ReleaseFinishNativeDelegate ReleaseFinishVMCallback {
			get {
				if (ReleaseFinish_cb_delegate == null)
					ReleaseFinish_cb_delegate = new ReleaseFinishNativeDelegate (ReleaseFinish_cb);
				return ReleaseFinish_cb_delegate;
			}
		}

		static void OverrideReleaseFinish (GLib.GType gtype)
		{
			OverrideReleaseFinish (gtype, ReleaseFinishVMCallback);
		}

		static void OverrideReleaseFinish (GLib.GType gtype, ReleaseFinishNativeDelegate callback)
		{
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) gtype.GetClassPtr()) + (long) class_abi.GetFieldOffset("release_finish"));
				*raw_ptr = Marshal.GetFunctionPointerForDelegate((Delegate) callback);
			}
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool ReleaseFinishNativeDelegate (IntPtr inst, IntPtr result, out IntPtr error);

		static bool ReleaseFinish_cb (IntPtr inst, IntPtr result, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				Permission __obj = GLib.Object.GetObject (inst, false) as Permission;
				bool __result;
				__result = __obj.OnReleaseFinish (GLib.AsyncResultAdapter.GetObject (result, false));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Permission), ConnectionMethod="OverrideReleaseFinish")]
		protected virtual bool OnReleaseFinish (GLib.IAsyncResult result)
		{
			return InternalReleaseFinish (result);
		}

		private bool InternalReleaseFinish (GLib.IAsyncResult result)
		{
			ReleaseFinishNativeDelegate unmanaged = null;
			unsafe {
				IntPtr* raw_ptr = (IntPtr*)(((long) this.LookupGType().GetThresholdType().GetClassPtr()) + (long) class_abi.GetFieldOffset("release_finish"));
				unmanaged = (ReleaseFinishNativeDelegate) Marshal.GetDelegateForFunctionPointer(*raw_ptr, typeof(ReleaseFinishNativeDelegate));
			}
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr error = IntPtr.Zero;
			bool __result = unmanaged (this.Handle, result == null ? IntPtr.Zero : ((result is GLib.Object) ? (result as GLib.Object).Handle : (result as GLib.AsyncResultAdapter).Handle), out error);
			return __result;
		}


		// Internal representation of the wrapped structure ABI.
		static GLib.AbiStruct _class_abi = null;
		static public new GLib.AbiStruct class_abi {
			get {
				if (_class_abi == null)
					_class_abi = new GLib.AbiStruct (new List<GLib.AbiField>{ 
						new GLib.AbiField("acquire"
							, GLib.Object.class_abi.Fields
							, (uint) Marshal.SizeOf(typeof(IntPtr)) // acquire
							, null
							, "acquire_async"
							, (uint) Marshal.SizeOf(typeof(IntPtr))
							, 0
							),
						new GLib.AbiField("acquire_async"
							, -1
							, (uint) Marshal.SizeOf(typeof(IntPtr)) // acquire_async
							, "acquire"
							, "acquire_finish"
							, (uint) Marshal.SizeOf(typeof(IntPtr))
							, 0
							),
						new GLib.AbiField("acquire_finish"
							, -1
							, (uint) Marshal.SizeOf(typeof(IntPtr)) // acquire_finish
							, "acquire_async"
							, "release"
							, (uint) Marshal.SizeOf(typeof(IntPtr))
							, 0
							),
						new GLib.AbiField("release"
							, -1
							, (uint) Marshal.SizeOf(typeof(IntPtr)) // release
							, "acquire_finish"
							, "release_async"
							, (uint) Marshal.SizeOf(typeof(IntPtr))
							, 0
							),
						new GLib.AbiField("release_async"
							, -1
							, (uint) Marshal.SizeOf(typeof(IntPtr)) // release_async
							, "release"
							, "release_finish"
							, (uint) Marshal.SizeOf(typeof(IntPtr))
							, 0
							),
						new GLib.AbiField("release_finish"
							, -1
							, (uint) Marshal.SizeOf(typeof(IntPtr)) // release_finish
							, "release_async"
							, "reserved"
							, (uint) Marshal.SizeOf(typeof(IntPtr))
							, 0
							),
						new GLib.AbiField("reserved"
							, -1
							, (uint) Marshal.SizeOf(typeof(IntPtr)) * 16 // reserved
							, "release_finish"
							, null
							, (uint) Marshal.SizeOf(typeof(IntPtr))
							, 0
							),
					});

				return _class_abi;
			}
		}


		// End of the ABI representation.

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe bool g_permission_acquire(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public unsafe bool Acquire(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_permission_acquire(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void g_permission_acquire_async(IntPtr raw, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void AcquireAsync(GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_permission_acquire_async(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe bool g_permission_acquire_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public unsafe bool AcquireFinish(GLib.IAsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_permission_acquire_finish(Handle, result == null ? IntPtr.Zero : ((result is GLib.Object) ? (result as GLib.Object).Handle : (result as GLib.AsyncResultAdapter).Handle), out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr g_permission_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = g_permission_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void g_permission_impl_update(IntPtr raw, bool allowed, bool can_acquire, bool can_release);

		public void ImplUpdate(bool allowed, bool can_acquire, bool can_release) {
			g_permission_impl_update(Handle, allowed, can_acquire, can_release);
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe bool g_permission_release(IntPtr raw, IntPtr cancellable, out IntPtr error);

		public unsafe bool Release(GLib.Cancellable cancellable) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_permission_release(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void g_permission_release_async(IntPtr raw, IntPtr cancellable, GLibSharp.AsyncReadyCallbackNative cb, IntPtr user_data);

		public void ReleaseAsync(GLib.Cancellable cancellable, GLib.AsyncReadyCallback cb) {
			GLibSharp.AsyncReadyCallbackWrapper cb_wrapper = new GLibSharp.AsyncReadyCallbackWrapper (cb);
			cb_wrapper.PersistUntilCalled ();
			g_permission_release_async(Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, cb_wrapper.NativeDelegate, IntPtr.Zero);
		}

		[DllImport("gio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe bool g_permission_release_finish(IntPtr raw, IntPtr result, out IntPtr error);

		public unsafe bool ReleaseFinish(GLib.IAsyncResult result) {
			IntPtr error = IntPtr.Zero;
			bool raw_ret = g_permission_release_finish(Handle, result == null ? IntPtr.Zero : ((result is GLib.Object) ? (result as GLib.Object).Handle : (result as GLib.AsyncResultAdapter).Handle), out error);
			bool ret = raw_ret;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}


		// Internal representation of the wrapped structure ABI.
		static GLib.AbiStruct _abi_info = null;
		static public new GLib.AbiStruct abi_info {
			get {
				if (_abi_info == null)
					_abi_info = new GLib.AbiStruct (new List<GLib.AbiField>{ 
						new GLib.AbiField("priv"
							, GLib.Object.abi_info.Fields
							, (uint) Marshal.SizeOf(typeof(IntPtr)) // priv
							, null
							, null
							, (uint) Marshal.SizeOf(typeof(IntPtr))
							, 0
							),
					});

				return _abi_info;
			}
		}


		// End of the ABI representation.

#endregion
	}
}
